var Path = require("path");
var Config = require('nconf');
var _ = require("underscore");
var _s = require('underscore.string');
var Purdy = require("purdy");
var Shell = require("shelljs");

var internals = {};

internals.sgrColors = {
    "reset": "\x1b[0m",
    "black": "\x1b[30m",
    "red": "\x1b[31m",
    "green": "\x1b[32m",
    "yellow": "\x1b[33m",
    "blue": "\x1b[34m",
    "magenta": "\x1b[35m",
    "cyan": "\x1b[36m",
    "white": "\x1b[37m",

    bold: {
        "black": "\x1b[30;1m",
        "red": "\x1b[31;1m",
        "green": "\x1b[32;1m",
        "yellow": "\x1b[33;1m",
        "blue": "\x1b[34;1m",
        "magenta": "\x1b[35;1m",
        "cyan": "\x1b[36;1m",
        "white": "\x1b[37;1m",
    }
};

internals.purdyOptions = {
    path: true
};

exports.sendEmail = require("./send-email");

exports.logCallsite = function logCallsite(callsiteObj) {

    var colors = internals.sgrColors;

    // callsiteObj is an array of strings, prepared by Hoek (not the origin callsite obj, which has methods like .getLineNumber())
    var funcName = callsiteObj[3];
    var lineNumber = callsiteObj[1];
    var dirName = Path.dirname(callsiteObj[0]);
    var baseName = Path.basename(callsiteObj[0]);

    var output = colors.bold.cyan + (funcName || "anonymous") + "()" + colors.reset +
        " (" + dirName + "/" + colors.bold.cyan + baseName + colors.reset +
        ":" + colors.bold.green + lineNumber + colors.reset + ")";

    //server.log(["stack"], output);

    return output;
};

exports.log = function log(){

    if(_.isObject(arguments[0])){
        Purdy(arguments[0], internals.purdyOptions);
    }

    if(_.isString(arguments[0]) && arguments.length > 1){
        Purdy(arguments[0] + ":");
        Purdy(arguments[1], internals.purdyOptions);
    }
};

// todo: use execFile
exports.shellExec = function(commands){

    var output;

    commands.forEach(function(command){

        console.log("[shelljs] Executing command: " + command);
        output = Shell.exec(command, {silent: true});

        if(output.code!==0){
            console.log("");
            var message = "The following command did not finish:\n" + command;
            throw new Error(message);
        }
    });
};

exports.changeCase = function changeCase(obj, methodName){

    var method = _s[methodName];
    if (!method) {
        throw new Error("The method '" + methodName + "'' doesn't exist in underscore.string");
    }

    // piggy-back on the .clone method from Hoek@2.16.3
    function clone(obj, seen) {

        if (typeof obj !== 'object' ||
            obj === null) {

            return obj;
        }

        seen = seen || { orig: [], copy: [] };

        var lookup = seen.orig.indexOf(obj);
        if (lookup !== -1) {
            return seen.copy[lookup];
        }

        var newObj;
        var cloneDeep = false;

        if (!Array.isArray(obj)) {
            if (Buffer.isBuffer(obj)) {
                newObj = new Buffer(obj);
            }
            else if (obj instanceof Date) {
                newObj = new Date(obj.getTime());
            }
            else if (obj instanceof RegExp) {
                newObj = new RegExp(obj);
            }
            else {
                var proto = Object.getPrototypeOf(obj);
                if (proto &&
                    proto.isImmutable) {

                    newObj = obj;
                }
                else {
                    newObj = Object.create(proto);
                    cloneDeep = true;
                }
            }
        }
        else {
            newObj = [];
            cloneDeep = true;
        }

        seen.orig.push(obj);
        seen.copy.push(newObj);

        if (cloneDeep) {
            var keys = Object.getOwnPropertyNames(obj);
            for (var i = 0, il = keys.length; i < il; ++i) {
                var key = keys[i];
                var descriptor = Object.getOwnPropertyDescriptor(obj, key);
                if (descriptor &&
                    (descriptor.get ||
                     descriptor.set)) {

                    Object.defineProperty(newObj, method(key), descriptor);
                }
                else {
                    newObj[method(key)] = clone(obj[key], seen);
                }
            }
        }

        return newObj;
    }

    return clone(obj);

};

exports.getErrMsg = function getErrMsg(err){

    if(err.msg){
        return err.msg;
    }

    // if this is an error generated by pg, the following properties should be
    // present in the err object and contain useful information
    var msg = "\n\n-----------------------  pg error  -----------------------\n";
    msg = msg + (err.toString      ? "\ndescription: " + err.toString()         : "");
    msg = msg + (err.detail        ? "\ndetail: " + err.detail                  : "");
    msg = msg + (err.code          ? "\ncode: " + err.code                      : "");
    msg = msg + (err.table         ? "\ntable: " + err.schema + "." + err.table : "");
    msg = msg + (err.column        ? "\ncolumn: " + err.column                  : "");
    msg = msg + (err.hint          ? "\nhint: " + err.hint                      : "");
    msg = msg + (err.where         ? "\nwhere: " + err.where                    : "");
    msg = msg + (err.internalQuery ? "\ninternalQuery: " + err.internalQuery    : "");
    msg += "\n--------------------------------------------------------\n\n";

    return msg;
};

exports.register = function(server, options, next){

    server.method({
        name: "utils.logCallsite",
        method: function(callsiteObj){

            var output = exports.logCallsite(callsiteObj);
            server.log(["stack"], output);
            return output;
        }
    });

    server.method({
        name: "utils.log", 
        method: exports.log
    });

    server.method({
        name: "utils.changeCase", 
        method: exports.changeCase
    });

    return next();
};

exports.register.attributes = {
    name: Path.parse(__dirname).name,
    dependencies: []
};

